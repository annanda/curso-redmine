{"name":"Curso-redmine","tagline":"Curso de Redmine","body":"# Curso Redmine\r\n## Ementa\r\n- [O Curso](#o-curso)\r\n- [Ambiente de Desenvolvimento](#ambiente-de-desenvolvimento)\r\n  - [IDEs](#ides)\r\n    - [Sublime](#sublime)\r\n    - [Atom](#atom)\r\n    - [RubyMine](#rubymine)\r\n  - [Ruby](#ruby)\r\n    - [Introdução](#introdução)\r\n    - [Instalar](#instalar)\r\n  - [Rails](#rails)\r\n    - [Introdução](#introdução-1)\r\n    - [Instalar](#instalar-1)\r\n  - [Redmine](#redmine)\r\n    - [Introdução](#introdução-2)\r\n    - [Instalar](#instalar-2)\r\n- [Fluxo de Dados](#fluxo-de-dados)\r\n- [Estrutura de Pastas](#estrutura-de-pastas)\r\n  - [Subpastas importantes](#subpastas-importantes)\r\n    - [App](#app)\r\n    - [Public](#public)\r\n- [Plugins](#estrutura-plugins)\r\n  - [Quando devemos desenvolver um plugin?](#quando-devemos-desenvolver-um-plugin)\r\n  - [Como criar um plugin](#como-criar-um-plugin)\r\n  - [Criando um modelo](#criando-um-modelo)\r\n  - [Criando um Controller](#criando-um-controller)\r\n  - [Adicionando rota](#adicionando-rota)\r\n  - [Adicionando um link no menu](#adicionando-um-link-no-menu)\r\n  - [Internacionalização](#internacionalização)\r\n  - [Criando uma View](#criando-uma-view)\r\n  - [Assets](#assets)\r\n  - [Permissões](#permissões)\r\n  - [Módulos](#módulos)\r\n  - [Hooks](#hooks)\r\n    - [Hooks nas Views](#hooks-nas-views)\r\n    - [Hooks nos Controllers](#hooks-nos-controllers)\r\n    - [Fazendo um plugin ser configurável](#fazendo-um-plugin-ser-configurável)\r\n    - [Sobrescrevendo um Modelo](#sobrescrevendo-um-modelo)\r\n    - [Sobrescrevendo um Controller](#sobrescrevendo-um-controller)\r\n    - [Sobrescrevendo uma View](#sobrescrevendo-um-modelo)\r\n- [Futuro](#futuro)\r\n- [Colaboradores](#colaboradores)\r\n- [Alunos](#alunos)\r\n\r\n--------------------------------------------------------------------------------\r\n\r\n### O Curso\r\nNeste curso veremos como desenvolver plugins para Redmine 2.6. Com foco na teoria e técnicas de programação da framework Rails e como se aplica ao Redmine.\r\n\r\n<sub><sup>Não é um curso de Ruby on Rails</sup></sub>\r\n\r\n### Ambiente de Desenvolvimento\r\n#### IDES\r\n##### Sublime\r\n[![Sublime Logo](https://raw.githubusercontent.com/victorlcampos/curso-redmine/master/imagens/sublime-logo.png) ](http://www.sublimetext.com/)\r\n\r\nO Sublime é um editor de texto poderoso, rápido e multiplataforma. Atualmente está na sua versão 3.0, custando 70 obamas.\r\n\r\n##### Atom\r\n[![Atom s2s2](https://cloud.githubusercontent.com/assets/72919/2874231/3af1db48-d3dd-11e3-98dc-6066f8bc766f.png) ](https://atom.io/)\r\n\r\nAtom é sem dúvida a minha recomendação para quem quer seguir com desenvolvimento ruby. Um editor estável, open source e desenvolvido/mantido pelo próprio GitHub.\r\n\r\nPoderia passar horas falando o porque eu gosto do atom, mas não é o foco do curso.\r\n\r\n##### RubyMine\r\n[![Ruby Mine $$](https://confluence.jetbrains.com/download/attachments/20238/RM_logo.gif?version=1&modificationDate=1373554086000)](https://www.jetbrains.com/ruby/)\r\n\r\nComo escrito no próprio site da JetBrain, a IDE de ruby mais inteligente. Porque não uso? Primeiro, porque acredito que IDE traga mais distrações do que o benefícios, segundo porque demora mais tempo para iniciar que o Atom, terceiro porque custa 199 obamas no primeiro ano e 99 para renovar a licença. E não acho que esse valor se pague.\r\n\r\nMas se você é desenvolvedor Java e não consegue viver sem autocomplete, vale a pena testar os 30 dias de trial.\r\n\r\n<sub><sup>PS: Não citei o eclipse porque era bem ruim quando usei para ruby(a uns 2 anos atrás) e nunca mais voltei, mas se você quiser testar, fique a vontade.</sup></sub>\r\n\r\n#### Ruby\r\n##### Introdução\r\n![](http://iwanttolearnruby.com/images/ruby-style-guide.gif)\r\n\r\nRuby é uma linguagem de programação de 1995 onde <sub><sup>quase</sup></sub> tudo é um objeto. Uma linguagem moderna, possuindo tipos dinâmicos, lambda function e altamente influenciada por programação funcional.\r\n\r\nDiferente do Java onde o tipo é explícito, em Ruby a tipagem é conhecida como Duck Typing, se um argumento tem todos os métodos que o método precisa para usá-lo, o método vai aceita-lo como argumento. O que não significa que a variável não tenha tipo, todo objeto tem o método .class, que retorna a classe que ele pertence.\r\n\r\nOutra diferença com o Java é que as classes em Ruby são abertas, mas o que isso significa? Significa que após declarar uma classe, você pode abri-la novamente e altera-la. Continuou sem entender? Vamos para o Exemplo:\r\n\r\n```ruby\r\nclass A\r\n  def a\r\n    print 'a'\r\n  end\r\nend\r\n\r\nobj = A.new\r\nobj.a\r\n=> a\r\n\r\nclass A\r\n  def b\r\n    print 'b'\r\n  end\r\nend\r\n\r\nobj = A.new\r\nobj.a\r\n=> a\r\nobj.b\r\n=> b\r\n```\r\n\r\nDepois de declarar a classe A pela segunda vez, quando iniciei um novo objeto dessa classe, ele passou a ter ambos os métodos. Mas o que ocorreria se eu tivesse declarado o mesmo método novamente?\r\n\r\n```ruby\r\nclass A\r\n  def a\r\n    print 'novo a'\r\n  end\r\nend\r\n\r\nobj = A.new\r\nobj.a\r\n=> novo a\r\nobj.b\r\n=> b\r\n```\r\n\r\nSe o mesmo método for declarado duas vezes, a última declaração passa a valer. Essa característica da linguagem, evita as milhões de classe Utils que criamos no Java e facilita a criação de plugins.\r\n\r\nE como ruby é altamente influenciada por programação funcinal, toda função tem um retorno, não existe função void em Ruby.\r\n\r\n##### Instalar\r\n![](https://rvm.io/images/rvm-logo-all-happy.png)\r\n\r\nPara instalar o Ruby no Linux **(Usem LINUX)**, vamos utilizar um gerenciador de versão do Ruby para conseguirmos ter mais de uma versão rodando na mesma máquina.\r\n\r\nOs dois gerênciadores mais famosos são o rbenv e o rvm. Para esse curso vamos utilizar o rvm.\r\n\r\n<sub><sup>Escolha baseada em gosto pessoal, se quiserem se aventurar no rbenv ele também é muito bom.</sup></sub>\r\n\r\n```sh\r\n$ apt-get update\r\n$ apt-get install -y subversion git telnet\r\n$ apt-get install apt-get install -y libmysqlclient-dev freetds-dev imagemagick libmagickcore-dev libmagickwand-dev libcurl4-openssl-dev apache2-threaded-dev libapr1-dev libaprutil1-dev curl\r\n\r\n$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\r\n\r\n$ \\curl -sSL https://get.rvm.io | bash -s stable\r\n\r\n$ rvm requirements\r\n$ rvm install 1.9.3\r\n$ rvm use 1.9.3 --default\r\n```\r\n\r\nO Redmine 2.6 usa o ruby 1.9.3, por isso instalamos ele.\r\n\r\n<sub><sub>Enquanto escrevia esse curso, verifiquei que na vesão [2.6.6](http://www.redmine.org/issues/19652) o Redmine passou a suportar o Ruby 2.2, mas como ainda não tive tempo de testar, vou seguir com a 1.9.3</sub><sub>\r\n\r\n#### Rails\r\n##### Introdução\r\n![](http://rubyonrails.org/images/rails.png)\r\n\r\nO Rails é uma framework MVC baseado em dois princípios básicos que você deve **SEMPRE** seguir, Convenção sobre Configuração e o Dry(Don't repeat yourself).\r\n\r\nAtualmente se encontra na versão 4.2.3, mas no redmine 2.6 utilizaremos a 3.2.\r\n\r\n##### Instalar\r\n![](https://rubygems.org/favicon.ico)\r\n\r\nPodemos instalar o rails utilizando o RubyGem, uma gem seria o equivalente do jar no Java. O RubyGem é um instalador de _gems_ que já é instalado junto com o ruby pelo rvm, ele funciona parecido com o apt-get do ububtu.\r\n\r\n```sh\r\n$ sudo gem install rails -v 3.2.x\r\n```\r\n\r\nVamos instalar a versão 3.2 do rails pois é a última compatível com o redmine 2.6\r\n\r\n#### Redmine\r\n##### Introdução\r\n![](http://www.redmine.org/attachments/3458/redmine_logo_v1.png)\r\n\r\nO Redmine é um gerenciador de projeto **muito** flexível, extensível e configurável. Como o código é aberto, conseguimos utiliza-lo para atender as mais variádas demandas dos clientes. As principais features nativas são:\r\n- Multiple projects support\r\n- Flexible role based access control\r\n- Flexible issue tracking system\r\n- Gantt chart and calendar\r\n- News, documents & files management\r\n- Feeds & email notifications\r\n- Per project wiki\r\n- Per project forums\r\n- Time tracking\r\n- Custom fields for issues, time-entries, projects and users\r\n- SCM integration (SVN, CVS, Git, Mercurial, Bazaar and Darcs)\r\n- Issue creation via email\r\n- Multiple LDAP authentication support\r\n- User self-registration support\r\n- Multilanguage support\r\n- Multiple databases support\r\n\r\n##### Instalar\r\nPara instalar o Redmine, vamos utilizar a última versão estável do redmine 2.6, que no momento de criação desse curso era a 2.6.6\r\n\r\n```sh\r\n$ svn co https://svn.redmine.org/redmine/branches/2.6.6-stable redmine-2.6.6\r\n\r\n$ cd redmine-2.6.6\r\n```\r\n\r\nTendo o código do redmine, precisamos configurar o arquivo do banco de dados e o arquivo de configuração de e-mail. Por enquanto vamos utilizar o examplo do próprio redmine.\r\n\r\n```sh\r\n$ cp ./config/database.yml{.example,}\r\n$ cp ./config/configuration.yml{.example,}\r\n```\r\n\r\nAssim como no Java temos o Maven para baixar as dependências, no Ruby temos o Bundle, para utiliza-lo basta fazer:\r\n\r\n```sh\r\n$ bundle install\r\n```\r\n\r\nEle irá olhar o arquivo Gemfile, na pasta raiz do projeto e instalar todas as dependências que lá estiver.\r\n\r\n> O Bundle faz tudo que o Maven faz?\r\n\r\n**NÃO**, ele, diferente do Maven, se foca em fazer bem uma única coisa: gerênciar dependências.\r\n\r\nPara automatizar tarefas, temos o **rake**, vamos utilizar para gerar o token de segurança de sessão.\r\n\r\n```sh\r\n$ rake generate_secret_token\r\n```\r\n\r\nTambém precisamos gerar as tebelas do banco de dados que o redmine usa. O Rails por padrão possui migrações, arquivos em ruby(.rb) que descreve as operações que devemos realizar no banco.\r\n\r\nPodemos com o rake rodar todas essas migrações e o Rails se encarrega de transformar no sql certo para o banco descrito no database.yml\r\n\r\n```sh\r\n$ rake db:create\r\n$ rake db:migrate\r\n```\r\n\r\nPronto, agora estamos pronto para rodar o Redmine\r\n\r\n```sh\r\n$ rails server\r\n```\r\n\r\n### Fluxo de Dados\r\nA primeira coisa para se entender como programar utilizando Ruby on Rails é entender o fluxo de dados.\r\n\r\nQuando um request chega ele segue o fluxo:\r\n- Tenta encaixar a url do request em algum partner cadastrado nos arquivos de rotas.\r\n  - Podemos verificar todas as rotas cadastradas rodando o comando  \"_rake routes_\" no terminal\r\n- O arquivo de rotas dira para o Rails qual o controller ele deve chamar e qual action ele deve executar.\r\n  - Uma action é o nome de um método de um controller\r\n- Uma action pode redirectionar para outra action ou renderizar uma view.\r\n  - Por padrão o Rails renderiza a view com o mesmo nome da action dentro da pasta com o mesmo nome do controller. **(Convenção sobre Configuração)**\r\n- A view encherga as variáveis de instâncias(@) do controller\r\n\r\nEntender e praticar esse fluxo é de extrema importância para saber encontrar o que você deseja modificar no Redmine e saber em qual parte do código está dando erro. Com o tempo você perceberá que as coisas estão onde devem estar.\r\n\r\n### Estrutura de Pastas\r\n![](https://raw.githubusercontent.com/victorlcampos/curso-redmine/master/imagens/estrutura-pastas.png)\r\n\r\n- app\r\n  - Pasta onde ficam os arquivos da aplicação como models, controllers, views, etc\r\n- config\r\n  - Pasta onde ficam os arquivos de configuração de banco, ambiente, **rotas**, locales\r\n- db\r\n  - Pasta onde se encontra as migrações do banco\r\n- doc\r\n  - Pasta para guardar as documentações da aplicação\r\n- extra\r\n  - Pasta com exemplo de plugin\r\n- files\r\n  - Pasta onde o Redmine guarda os arquivos anexados\r\n- lib\r\n  - Pasta onde ficam as bibliotecas de código desenvolvida, como rake taskes, patches, etc\r\n- plugins\r\n  - Pasta onde ficam guardados os plugins desenvolvidos para o Redmine, é aqui onde faremos 90% do desenvolvimento\r\n- public\r\n  - Pasta onde ficam os arquivos estáticos servidos pelo webserver\r\n- script\r\n  - Contêm o script para inicialização do rails\r\n- test\r\n  - Pasta com os testes automatizados do Redmine\r\n\r\n#### Subpastas importantes\r\n##### App\r\n![](https://raw.githubusercontent.com/victorlcampos/curso-redmine/master/imagens/estrutura-app.png)\r\n\r\nComo mencionado a pasta app contêm os controllers, models e views, mas em qual subpasta eles ficam? Bom, vou deixar você, caro leitor, descobrir sozinho.\r\n\r\nDescobriu? Ótimo, agora vamos olhar para as views. As views possuem também subpastas, cada uma delas com o mesmo nome do controller. Assim o rails sabe qual view renderizar quando uma action for chamada. Ele vai dentro da **pasta view > nome_controller > nome_action.{html, js, xml, etcc}.erb**.\r\n\r\nCaso ele não encontre o arquivo correspondentes, ele vai buscar na pasta com o mesmo nome da superclasse do controller e assim sucessivamente. Caso ele por fim não encontre, a página 404 do public é renderizada.\r\n\r\n##### Public\r\n![](https://raw.githubusercontent.com/victorlcampos/curso-redmine/master/imagens/estrutura-public.png)\r\n\r\nNa pasta public ficam as imagens, javascript e css(pasta stylesheets), nela também ficam os temas do redmine.\r\n\r\nO Redmine aceita temas customizados, um tema consiste em um conjunto de css/javascripts e dentro da configuração do Redmine é possível escolher qual tema o usuário vai ver.\r\n\r\nO Redmine carrega automaticamente todas as pastas que se encontram dentro da pasta theme e disponibiliza para o administrador escolher qual utilizar.\r\n\r\n![](https://raw.githubusercontent.com/victorlcampos/curso-redmine/7daaf9dff1b3ed0c4f7178d7ec93f97343e3f5a3/imagens/themas.png)\r\n\r\nO Redmine possui uma lista de themas feitos pela comunidade para você não partir do zero.\r\n\r\n[Lista de temas da Comunidade](http://www.redmine.org/projects/redmine/wiki/Theme_List)\r\n\r\n### Plugins\r\n#### Quando devemos desenvolver um plugin?\r\n\r\nDevemos desenvolver um plugin quando:\r\n\r\n1. O redmine não faz o que queremos que ele faça **E**\r\n2. Não existe um plugin Open Source que faça o que a gente gostaria que o Redmine fizesse.\r\n\r\nSe existir um plugin open source que faça parecido, faça um fork do plugin e contribua com ele. Assim todos ganham =).\r\n\r\n#### Como criar um plugin\r\nO Redmine provê um generator para criação da estrutura padrão de um plugin\r\n\r\n```sh\r\n$ rails generate redmine_plugin <plugin_name>\r\n```\r\n\r\nRodando por exemplo:\r\n\r\n```sh\r\n$ rails generate redmine_plugin polls\r\n```\r\n\r\nEle irá criar dentro da pasta plugins:\r\n\r\n![](https://raw.githubusercontent.com/victorlcampos/curso-redmine/master/imagens/pasta-plugins.png)\r\n\r\nReparem, ele criou uma estrutura muito parecida com a estrutura do próprio redmine, de diferente temos:\r\n\r\n* assets\r\n  * Nessa pasta ficarão as imagens, javascript e css do plugin. O Redmine ao iniciar irá pegar esses arquivos e colocar na pasta plugin_assets dentro da pasta public\r\n\r\nEditando o init.rb veremos\r\n\r\n```rb\r\n  Redmine::Plugin.register :polls do\r\n    name 'Polls plugin'\r\n    author 'Author name'\r\n    description 'This is a plugin for Redmine'\r\n    version '0.0.1'\r\n    url 'http://example.com/path/to/plugin'\r\n    author_url 'http://example.com/about'\r\n  end\r\n```\r\n\r\nO init.rb é o arquivo que o redmine chama ao carregar o plugin, iremos utilizar mais ele no futuro. Mas por enquanto podemos somente modificar as informações do plugin.\r\n\r\nEssas informações irão aparecer da seguinte forma no redmine:\r\n\r\n![](https://raw.githubusercontent.com/victorlcampos/curso-redmine/master/imagens/informacoes-plugins.png)\r\n\r\n#### Criando um modelo\r\n\r\nNovamente, para criar um modelo dentro de um plugin, podemos chamar o generator do próprio redmine\r\n```sh\r\n$ rails generate redmine_plugin_model <plugin_name> <model_name> [field[:type][:index] field[:type][:index] ...]\r\n```\r\n\r\nPodendo reparar que é muito parecido com o generator de modelo do rails.\r\nEntão vamos criar um modelo poll dentro do plugins polls, que vai ter uma question do tipo string, uma contagem de sim e uma contagem de não, ambos do tipo numérico.\r\n\r\n```sh\r\n$ rails generate redmine_plugin_model polls poll question:string yes:integer no:integer\r\n    create  plugins/polls/app/models/poll.rb\r\n    create  plugins/polls/test/unit/poll_test.rb\r\n    create  plugins/polls/db/migrate/001_create_polls.r\r\n```\r\n\r\nReparem, ele criou um modelo na pasta models e uma migração na pasta migrations\r\n\r\nVamos olhar essa migração:\r\n\r\n```rb\r\nclass CreatePolls < ActiveRecord::Migration\r\n  def change\r\n    create_table :polls do |t|\r\n      t.string :question\r\n      t.integer :yes\r\n      t.integer :no\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nVamos entender a migração, ela chama uma função *create_table* que recebe como argumento um símbolo (:polls) e um bloco de código que recebe também um argumento(t).\r\n\r\n> Primeiro, o que é um símbolo? Você deve estar se perguntando\r\n\r\nUm simbolo é parecido com a String do Java. A diferença entre \"polls\" e :polls é que o primeiro é mutável, se você fizer:\r\n\r\n```rb\r\n  a = \"a\"\r\n  a += \"b\"\r\n  print a\r\n    => \"ab\"\r\n  a = nil\r\n```\r\nQuando o GC for executado, não teremos nada alocado na memória.\r\n\r\nJá um símbolo, não possui um método para concatenar e se executácemos:\r\n\r\n```rb\r\n  a = :a\r\n  print a\r\n    => \"a\"\r\n  a = nil\r\n```\r\n\r\nO símbolo :a, não seria arrancado da memória. Isso é perigoso quando criamos símbolos dinamicamente e é uma [vunerabilidade](http://brakemanscanner.org/docs/warning_types/denial_of_service/) conhecida do Rails.\r\n\r\nMas porque então usamos ele ao invés de String, a resposta é simples: desempenho.\r\n\r\nSe você cria um símbolo de maneira controlada, sempre que você for acessa-lo, não precisará realocar memória e não importa quantas variáveis apontem para ele, elas vão estar consumindo a mesma quantidade de memória, pois estarão apontando sempre para a mesma posição.\r\n\r\n> Agora que já entendi o que é um símbolo, o que diabos é passar um bloco de código como argumento?\r\n\r\nBom, em ruby uma função pode receber um bloco de código e executa-lo dentro dela. O equivalente em Java 7 seria instanciar uma interface e preencher os métodos, muito usado nos handlers da vida.\r\n\r\nNo caso da função create_table ela executa o que tem que executar, instância um objeto e passa para a nossa função anônima. Como o ruby é Duck Typing, se o objeto t recebido pela nossa função anônima tiver todos os métodos necessários para o bloco de código ser executado, então o bloco será executado sem problema.\r\n\r\nEsse bloco irá chamar os métodos do objeto t que criam as colunas, o método string cria uma coluna do tipo string, o integer do tipo integer, etc...\r\nO método create_table cria sozinho a coluna id e os timestamps.\r\n\r\nPara saber mais sobre as migrações do Rails acesse http://guides.rubyonrails.org/v3.2.21/migrations.html\r\n\r\nPara executar as migrações dentro dos plugins:\r\n\r\n```sh\r\n$ rake redmine:plugins:migrate\r\nMigrating polls (Polls plugin)...\r\n==  CreatePolls: migrating ====================================================\r\n-- create_table(:polls)\r\n   -> 0.0323s\r\n==  CreatePolls: migrated (0.0324s) ===========================================\r\n```\r\n\r\nO rails irá criar a table a as colunas para você, \"indendente\" do banco que esteja configurado no seu database.yml\r\n\r\nUtilizando **convenção sobre configuração**, ele irá atribuir todas as colunas da tabela polls(plural) ao modelo poll(sigular) como métodos, já com getters & setters\r\n\r\n```rb\r\nclass Poll < ActiveRecord::Base\r\n  unloadable\r\nend\r\n\r\npoll = Poll.new\r\npoll.question = \"Question 1\"\r\nprint poll.question\r\n=> \"Question 1\"\r\nprint poll.yes\r\n=> nil\r\n```\r\n#### Criando um Controller\r\nVocê já deve ter imaginado que o Redmine possui um generator para o controller\r\n\r\n```sh\r\n$ rails generate redmine_plugin_controller <plugin_name> <controller_name> [<actions>]\r\n```\r\n\r\nSeguindo nosso exemplo, podemos criar um controller para as enquetes\r\n\r\n```sh\r\n$ rails generate redmine_plugin_controller polls polls\r\n  create  plugins/polls/app/controllers/polls_controller.rb\r\n  create  plugins/polls/app/helpers/polls_helper.rb\r\n  create  plugins/polls/test/functional/polls_controller_test.rb\r\n```\r\n\r\nÉ uma boa prática seguir o padrão rest no rails que consiste nas actions:\r\n\r\n| método HTTP | Nome da Action | Motivo                    |\r\n| ----------- | -------------- | ------------------------- |\r\n| GET         | index          | Listar                    |\r\n| GET         | show           | Mostrar                   |\r\n| GET         | new            | Formulário de criação     |\r\n| POST        | create         | Gravar modelo no banco    |\r\n| GET         | edit           | Formulário de ediçào      |\r\n| PUT/PATCH   | update         | Atualizar modelo no banco |\r\n| DELETE      | destroy        | Apagar modelo do banco    |\r\n\r\nPor exemplo, se quisermos criar uma *action* **index** para o controller devemos editar o controller para:\r\n\r\n```rb\r\nclass PollsController < ApplicationController\r\n  unloadable\r\n\r\n  def index\r\n    @polls = Poll.all # busca todas as enquetes do banco\r\n  end\r\nend\r\n```\r\n\r\n> Mas o que é essa variável com @?\r\n\r\nEm ruby o escopo da variável é definido da seguinte forma:\r\n\r\n* Sem @, escopo local, somente dentro do bloco de código que se encontra e bloco de códigos filhos\r\n* @, escopo instância, a variável é vista dentro de qualquer método do objeto\r\n* @@, escopo classe, no Java seriam as variáveis estáticas.\r\n\r\nComo já mencionado, as views enchergam as variáveis de instância dos controllers que as renderizaram.\r\n\r\n#### Adicionando rota\r\n\r\nComo explicado no [Fluxo de Dados](#fluxo-de-dados), quando uma url é chamada, o Rails busca nos arquivos de rota para qual controller#action ele deve direcionar o chamado. Cada plugin do redmine possui seu próprio arquivo de rotas, que fica dentro de _config/_.\r\n\r\nPodemos adicionar rotas de duas maneiras no Rails, a primeira no formato\r\n\r\n```rb\r\n  http_method url_partner, to: 'controller#action'\r\n```\r\n\r\nNo nosso exemplo seria:\r\n\r\n```rb\r\n  get 'pools', to: 'polls#index'\r\n```\r\n\r\nQuando acessácemos 'http://localhost:3000/polls' a action index do controller polls seria executada. Mas isso aparenta ser pouco **convenção sobre configuação** correto? Não parece ser muito rails way de fazer as coisas.\r\n\r\nBom, o rails possui o método _resources(controller_name, opts)_ que define todas as rotas do rest por padrão, então podemos definir:\r\n\r\n```rb\r\n  resources :polls\r\n```\r\n\r\nO rails possui por padrão uma rake task que lista todas as rotas criadas, vamos roda-la e usar o grep para filtrar somente as rotas do Controller polls\r\n\r\n```sh\r\n$ rake routes | grep polls\r\npolls GET          /polls(.:format) polls#index\r\n      POST         /polls(.:format) polls#create\r\nnew_poll GET          /polls/new(.:format) polls#new\r\nedit_poll GET          /polls/:id/edit(.:format) polls#edit\r\n poll GET          /polls/:id(.:format) polls#show\r\n      PUT          /polls/:id(.:format) polls#update\r\n      DELETE       /polls/:id(.:format) polls#destroy\r\n```\r\n\r\nPodemos reparar que todas as rotas necessárias para um serviço rest foram criadas. Se você paar para analisar um segundo, verá que a saída tem uma primeira coluna, o que será ela?\r\n\r\nPara você não sair escrevendo urls de forma hardcode, o rails cria por padrão dois métodos para cada rota, uma com sufixo path e uma com sufixo url, no nosso caso temos a polls_path e polls_url que tem como retorno /polls e http://localhost:3000/polls respectivamente.\r\n\r\nCom isso você não precisa modificar as urls em produção.\r\n\r\n> Ok, achei super legal, mas eu somente queria uma rota para index e ele criou várias que eu nem preciso usar.\r\n\r\nÉ verdade, por isso uma das opções que o método aceita é _only_. Podemos passar da seguinte maneira:\r\n\r\n```rb\r\n  resources :polls, only: [:index]\r\n```\r\n\r\nSendo agora somente criado a rota para a action index.\r\n\r\nAs rotas no rails são **MUITO** poderosas e poderia escrever um artigo somente sobre elas, então aconselho a dar uma olhada na guia oficial da linguagem para conhecer essa ferramenta incrível: http://guides.rubyonrails.org/routing.html\r\n\r\n#### Adicionando um link no menu\r\n\r\nO redmine possui diversos menus que você pode adicionar links para seus controllers, são eles:\r\n\r\n* :top_menu - menu superior esquerdo\r\n* :account_menu - menu superior direito, onde ficam os links de login e sair\r\n* :application_menu - menu principal fora de projetos\r\n* :project_menu - menu principal dentro de projetos\r\n* :admin_menu - menu dos administradores\r\n\r\nPara adicionar um menu, é necessário editar o arquivo init.rb e dentro do registro do plugin usar o método menu que tem a sintaxe:\r\n\r\n```rb\r\nmenu(menu_name, item_name, url, options={})\r\n```\r\n\r\nNo nosso exemplo ficaria:\r\n\r\n```rb\r\n  menu :application_menu, :polls, { controller: 'polls', action: 'index' }\r\n```\r\n\r\nAs opções que podemos passar são:\r\n\r\n* :param - the parameter key that is used for the project id (default is :id)\r\n* :if - a Proc that is called before rendering the item, the item is displayed only if it returns true\r\n* :caption - the menu caption that can be:\r\n  * a localized string Symbol\r\n  * a String\r\n  * a Proc that can take the project as argument\r\n* :before, :after - specify where the menu item should be inserted (eg. :after => :activity)\r\n* :first, :last - if set to true, the item will stay at the beginning/end of the menu (eg. :last => true)\r\n* :html - a hash of html options that are passed to link_to when rendering the menu item\r\n\r\nCom isso, criaremos um link para a nossa action no menu principal fora dos projetos\r\n\r\n#### Internacionalização\r\n\r\nA última coisa que falta para o menu, é que nossos clientes são Brasileiros e falam português, eles não querem polls e sim enquetes escrito no menu. Para fazer essa alteração, iremos criar um arquivo chamado pt-BR.yml dentro do config/locates do plugin e preencher com o seguinte conteúdo:\r\n\r\n```yml\r\npt-BR:\r\n  label_polls: Enquetes\r\n```\r\n\r\nCaso a opção caption não seja passada, **e ela não deve ser**, o redmine usa o _menu_name_ préfixado com _label_ para fazer a internacionalização do menu.\r\n\r\nPara saber mais sobre internacionalização no rails: http://guides.rubyonrails.org/i18n.html\r\n\r\n#### Criando uma View\r\n\r\nAgora que já temos uma rota, um controller e um botão que o usuário pode clicar para acessar nosso controller, precisamos codificar o que o usuário vai ver quando acessar nossa action. Como falado anteriormente o Rails vai procurar dentro da pasta com o mesmo nome do controller, _polls_, uma view com o mesmo nome da action, _index_.\r\n\r\nEntão criaremos o arquivo index.html.erb dentro da pasta app/views/polls do plugin e colocaremos o seguinte conteúdo:\r\n\r\n```erb\r\n<h1>Polls</h1>\r\n<ul>\r\n  <% @polls.each do |polls| %>\r\n    <li><%= polls.question %></li>\r\n  <% end %>\r\n</ul>\r\n```\r\n\r\n> O que diabos é .erb depois do .html?\r\n\r\nerb ou Embedded Ruby ou mesmo eRuby é o template padrão do Rails, existem diversos outros e a comunidade é bem dividida nesse ponto. O rails permite adicionar qualquar preprocessador de arquivo estático, sempre lendo as extensões da direita para esquerda. Se tivéssemos um javascript que quiséssemos que antes dele ser enviado para o cliente, rodasse código ruby, poderíamos criar o arquivo _file.js.erb_.\r\n\r\nPara entender mais sobre views, que é um dos pontos mais completos do Rails. Ele aceita partials, layouts, content, e várias outras features que facilitam o **dry**, leia o http://guides.rubyonrails.org/layouts_and_rendering.html\r\n\r\n#### Assets\r\n\r\nVale ressaltar que view feia não agrada cliente e muitas vezes precisamos escrever css e javascript específicos para um plugin. Para isso o redmine permite adicionar assets da seguinte forma:\r\n\r\n```erb\r\n<% content_for :header_tags do %>\r\n  <%= stylesheet_link_tag 'css_name', plugin: 'plugin_name' %>\r\n  <%= javascript_link_tag 'js_name' , plugin: 'plugin_name' %>\r\n<% end %>\r\n```\r\n\r\nSe você leu o guia sobre layout como sugerido, saberá que este _content_for_ rodará o bloco de código passado por ele na posição onde tiver um yield(:header_tags), que no nosso caso fica dentro da tag\r\n\r\n```html\r\n<header></header>\r\n```\r\n\r\nO método _stylesheet_link_tag_, adiciona um link para o css com nome _css_name_ que se encontra dentro do plugin com nome igual _plugin_name_, assim como o _javascript_link_tag_ fará para o javascript.\r\n\r\nCom isso você não precisará modificar o código direto dos assets do redmine para fazer uma modificação específica da sua view.\r\n\r\n#### Permissões\r\n#### Módulos\r\n#### Hooks\r\n##### Hooks nas Views\r\n##### Hooks nos controllers\r\n#### Fazendo um plugin ser configurável\r\n#### Sobrescrevendo um Modelo\r\n#### Sobrescrevendo um Controller\r\n#### Sobrescrevendo uma View\r\n\r\n### Fonte de Estudo\r\n\r\n1. http://guides.rubyonrails.org/\r\n2. http://www.redmine.org/projects/redmine/wiki/Plugin_Tutorial\r\n3. http://www.redmine.org/projects/redmine/wiki/Hooks\r\n4. http://www.redmine.org/projects/redmine/wiki/Plugin_Internals\r\n\r\n### Futuro\r\nA ideia de desenvolver o curso no github é deixar ele colaborativo e expansível, assim como o Redmine. Gerando assim uma apostila completa sobre o assunto, que se mantenha sempre atualizada.\r\n\r\n### Colaboradores\r\nQuem contribuir com esse material, pesso que mande um pull request adicionado o seu nome na lista abaixo.\r\n- Victor Lima Campos(victorlcampos)\r\n\r\n### Alunos\r\nQuem utilizar esse material para estudo, pesso que mande um pull request adicionado o seu nome na lista abaixo.\r\n- Victor Lima Campos(victorlcampos)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}